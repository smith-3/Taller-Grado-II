\chapter{MARCO TEÓRICO}

\section{Fundamentos sobre Gestión Académica y Horarios Universitarios}

La gestión académica se define como el conjunto de procesos y herramientas destinados a planificar, ejecutar y controlar las actividades formativas de una institución educativa. Dentro de este ámbito, la planificación de horarios cobra especial relevancia, ya que de su correcta organización dependen la eficiencia en el uso del tiempo de estudiantes y docentes, la optimización de recursos (aulas, laboratorios) y la calidad de la experiencia educativa.

En el contexto universitario, el problema de generación de horarios es un problema clásico de timetabling en investigación operativa, catalogado como NP–difícil. Consiste en asignar un conjunto de clases (asignaturas y grupos) a franjas horarias y espacios físicos, cumpliendo restricciones duras (sin solapamientos, disponibilidad de aulas y docentes) y, de ser posible, optimizando criterios blandos (minimizar tiempos muertos, equilibrar carga diaria). Existen algoritmos basados en coloración de grafos, algoritmos genéticos y heurísticas específicas que abordan este problema, aunque la complejidad crece rápidamente con el tamaño de la población estudiantil y la variedad de carreras.

En la Facultad de Ciencias y Tecnología de la UMSS, los horarios académicos se publican semestralmente en formato PDF en un portal web institucional. Esta estrategia presenta varias limitaciones:

\begin{itemize}
  \item Rigidez y falta de personalización: el estudiante no puede adaptar el horario a sus necesidades.
  \item Acceso limitado: la consulta en dispositivos móviles requiere descarga y lectura de PDF, con experiencia de usuario deficiente.
  \item Ausencia de alertas y sincronización: no existe mecanismo para detectar conflictos tras inscripciones o cambios.
\end{itemize}

Estos desafíos motivan el desarrollo de soluciones móviles especializadas que permitan organizar, consultar y optimizar horarios de forma dinámica y offline.

\section{Sistemas de Información Académicos}

Los sistemas de información académicos (SIA) son plataformas que soportan procesos de gestión de estudiantes, docentes y recursos. Se pueden clasificar en:

\begin{description}
  \item[\normalfont ERP/SIS empresariales:] integran múltiples módulos (inscripciones, finanzas, horarios), pero suelen ser monolíticos y costosos de personalizar.
  \item[\normalfont Sistemas modulares:] permiten añadir o quitar componentes según necesidad, favoreciendo la escalabilidad.
  \item[\normalfont Aplicaciones móviles especializadas:] diseñadas para tareas concretas (gestión de horarios, notificaciones), con experiencia de usuario optimizada.
\end{description}

En la UMSS, el sistema Cappuccino (S.C.E.S.I.) es un ejemplo de SIA web centrado en generación de horarios, pero carece de adaptabilidad móvil y capacidades de personalización. Por otro lado, aplicaciones comerciales como Smart Timetable o MyStudyLife ofrecen funciones avanzadas: sugerencias automáticas, alertas, sincronización en la nube y exportación en múltiples formatos. Sin embargo, dependen de servicios externos y requieren configuración previa.

\section{Arquitectura y Principios de Diseño}

Para garantizar que TecnoTime sea mantenible, extensible y testeable, se ha diseñado una única sección que integra arquitecturas, patrones y buenas prácticas:

\subsection{Clean Architecture}

\begin{itemize}
  \item Capas concéntricas (Onion):
    \begin{itemize}
      \item Presentación: UI (Jetpack Compose), ViewModels y navegación.
      \item Aplicación (Use Cases): orquesta la lógica de negocio pura.
      \item Dominio: entidades y contratos (repositorios), sin dependencias externas.
      \item Infraestructura: implementaciones concretas (Room, DAOs, mapeadores, servicios de red).
    \end{itemize}
  \item Principio de Dependencia: los detalles dependen de abstracciones, no al revés.
  \item Beneficios: aislamiento de la lógica, facilidad de pruebas unitarias y migraciones tecnológicas.
\end{itemize}

\subsection{MVVM y Programación Reactiva}

\begin{itemize}
  \item Model–View–ViewModel:
    \begin{itemize}
      \item View: declarativa con Compose, sin lógica de negocio.
      \item ViewModel: expone \texttt{StateFlow<UiState>} o \texttt{LiveData}, coordina casos de uso.
      \item Model: entidades de dominio o DTOs.
    \end{itemize}
  \item Reactividad: Coroutines \& Flow, uso de \texttt{collectAsState()} para enlazar UI.
  \item Testabilidad: ViewModels probados con mocks de casos de uso.
\end{itemize}

\subsection{Acceso a Datos: Repository \& DAO Pattern}

\begin{itemize}
  \item Repository Pattern:
    \begin{itemize}
      \item Implementa interfaces de dominio.
      \item Orquesta DAOs (Room), mapeadores y servicios de sincronización.
    \end{itemize}
  \item DAO Pattern:
    \begin{itemize}
      \item \texttt{@Dao}: \texttt{@Query}, \texttt{@Insert}, \texttt{@Update}, \texttt{@Delete}.
      \item \texttt{Flow} para consultas reactivas, \texttt{@Transaction} para transacciones.
      \item “Eliminación lógica” con flag \texttt{isActive}.
    \end{itemize}
  \item Ventajas: desacopla lógica de negocio y persistencia, facilita fakes en testing.
\end{itemize}

\subsection{Patrón Strategy para Scheduling}

\begin{itemize}
  \item Encapsula algoritmos como \texttt{\detokenize{MinimizeGaps}}, \texttt{\detokenize{PrioritizeTeachers}}, entre otros.
  \item La clase \texttt{\detokenize{ScheduleStrategyFactory}} selecciona estrategias según preferencias del usuario.
  \item Permite extender criterios sin modificar el núcleo del scheduler.
\end{itemize}


\subsection{Navegación Declarativa}

\begin{itemize}
  \item Single Activity con Navigation Compose (\texttt{NavHost}, \texttt{NavController}).
  \item Flujos unidireccionales: \texttt{UiState} → View → eventos → ViewModel.
  \item Coherencia de estado y transiciones simplificadas.
\end{itemize}

\subsection{Tareas en Segundo Plano}

\begin{itemize}
  \item \texttt{WorkManager} con \texttt{PeriodicWorkRequest}, back–off exponencial y restricciones.
  \item Workers notifican a la UI vía casos de uso y actualizan la base local.
\end{itemize}

\subsection{Domain–Driven Design (DDD) y Principios SOLID}

\begin{itemize}
  \item DDD:
    \begin{itemize}
      \item Ubiquitous Language: terminología compartida.
      \item Bounded Contexts: módulo de sincronización PDF desacoplado.
    \end{itemize}
  \item SOLID:
    \begin{enumerate}
      \item SRP: responsabilidad única.
      \item OCP: abierto a extensión, cerrado a modificación.
      \item LSP: substituibilidad de implementaciones.
      \item ISP: interfaces específicas y ligeras.
      \item DIP: inversión de dependencias entre dominio y datos.
    \end{enumerate}
\end{itemize}

\subsection{Manejo de Concurrencia y Recursos}

\begin{itemize}
  \item \texttt{viewModelScope} y structured concurrency.
  \item \texttt{Dispatchers.IO} para E/S, \texttt{Dispatchers.Default} para cómputo intensivo.
  \item Trabajo periódico con WorkManager que sobrevive a reinicios.
\end{itemize}

\subsection{Pruebas Automatizadas}

\begin{itemize}
  \item Unit Tests: JUnit4, MockK/Mockito para casos de uso y ViewModels.
  \item UI Tests: Espresso \& Compose Testing.
  \item Cobertura objetivo $\geq$ 80\% en la lógica de negocio.
\end{itemize}

\section{Tecnologías y Herramientas Utilizadas}

El desarrollo de TecnoTime se apoya en un ecosistema completamente nativo Android, organizado en varias categorías:

\subsection{Sistema de Construcción y Plugins}
\begin{itemize}
  \item Gradle Kotlin DSL \& Version Catalogs: uso de archivos \texttt{libs.versions.toml} para gestionar versiones centralizadas.
  \item Plugins principales: 
  \begin{flushleft}
  \justify
  \texttt{\detokenize{
    com.android.application,
    kotlin-android,
    kotlin-parcelize,
    kotlin-kapt/ksp,
    dagger.hilt.android.plugin,
    com.google.devtools.ksp,
    com.google.gms.google-services
  }}
  \end{flushleft}
\end{itemize}


\subsection{Configuración Android}
\begin{itemize}
  \item compileSdkVersion 35, minSdk 24, targetSdk 35: compatibilidad con dispositivos modernos.
  \item Java \& Kotlin 11: compilación dirigida a JVM 11.
  \item Build Features: \texttt{compose = true}, reglas de \texttt{proguardFiles}.
\end{itemize}

\subsection{Lenguaje y Coroutines}
\begin{itemize}
  \item Kotlin: sintaxis concisa, seguridad de nulidad.
  \item Coroutines \& Flow: manejo no bloqueante de E/S, streaming reactivo (\texttt{StateFlow}, \texttt{SharedFlow}).
\end{itemize}

\subsection{Interfaz de Usuario}
\begin{itemize}
  \item Jetpack Compose \& Material3: UI declarativa, theming dinámico.
  \item Navigation Compose: enrutamiento Declarativo.
  \item Accompanist: \texttt{systemuicontroller}, \texttt{pagers}, \texttt{permissions}.
  \item Coil: carga eficiente de imágenes.
\end{itemize}

\subsection{Persistencia y Configuración}
\begin{itemize}
  \item Room (SQLite): DAOs reactivas usando \mbox{\texttt{Flow}}, migraciones automáticas y transacciones atómicas mediante \mbox{\texttt{@Transaction}}.
  \item DataStore Preferences: configuración persistente y reactiva para UserSettings.
\end{itemize}

\subsection{Red, Scraping y PDF}
\begin{itemize}
  \item Jsoup: extracción de enlaces y metadatos.
  \item PDFBox-Android: parseo de contenido PDF.
  \item html-to-pdf-convertor: generación de informes HTML a PDF.
\end{itemize}

\subsection{Generación y Exportación de Documentos}
\begin{itemize}
  \item JExcelAPI (jxl): exportación a Excel.
  \item Canvas \& Compose: generación de imágenes de horario.
  \item Gson: serialización JSON.
  \item ThreeTenABP: APIs de fecha y hora.
\end{itemize}

\subsection{Notificaciones y Tareas en Segundo Plano}
\begin{itemize}
  \item NotificationCompat: generación de notificaciones locales previas a eventos.
\end{itemize}

\subsection{Pruebas}
\begin{itemize}
  \item JUnit4: pruebas unitarias de casos de uso y ViewModels.
  \item Espresso \& Compose UI Tests: pruebas de integración de la UI.
\end{itemize}

\section{Modelo de Datos y Entidades}

El diseño de la base de datos de TecnoTime responde a principios de modelado conceptual, normalización y eficiencia en la persistencia local. A continuación se detalla el enfoque teórico y las decisiones de diseño adoptadas.

\subsection{Modelado Conceptual de Datos}

Antes de pasar al esquema relacional, se definió un modelo entidad–relación (E/R) para capturar las entidades y sus asociaciones:

\begin{itemize}
  \item Carrera (\texttt{Careers):} representa cada carrera universitaria, con atributos de metadatos y sincronización.
  \item Asignatura (\texttt{Subjects):} contiene código, nombre, nivel y estado (electiva o activa).
  \item Grupo de asignatura (\texttt{SubjectGroups):} refleja la división de cada asignatura en grupos, con modalidad (teoría/práctica) y estado lógico.
  \item Horario de grupo (\texttt{GroupSchedules):} vincula cada grupo con día, hora, aula y docente.
  \item Selección del estudiante (\texttt{SelectedSubjects):} almacena la elección del usuario, con atributos de notificación, color y emoji.
  \item Eventos académicos (\texttt{AcademicEvents):} registros de exámenes, presentaciones u otros eventos vinculados a una selección.
  \item Docentes y Aulas (\texttt{Teachers, \texttt{Classrooms}):} catálogos auxiliares para enriquecer los horarios.
  \item Preferencias de usuario (\texttt{UserSettings):} configuración de la aplicación (formato de hora, tema, etc.).
\end{itemize}

Las relaciones N:M (muchos a muchos) entre carreras, asignaturas y grupos se resolvieron con tablas de cruce que garantizan flexibilidad y permiten escalar a nuevas asociaciones sin redundancia.

\subsection{Normalización y Tercera Forma Normal (3FN)}

Para evitar anomalías de inserción, actualización o eliminación, el esquema se normalizó hasta Tercera Forma Normal:

\begin{enumerate}
  \item Primera Forma Normal (1FN): cada tabla almacena valores atómicos, sin listas ni estructuras anidadas.
  \item Segunda Forma Normal (2FN): se eliminan dependencias parciales asegurando que cada atributo dependa de toda la clave primaria.
  \item Tercera Forma Normal (3FN): se eliminan dependencias transitivas, de modo que ningún atributo no clave dependa de otro atributo no clave.
\end{enumerate}

Por ejemplo, la información de docentes y aulas se separó en tablas independientes (\texttt{Teachers}, \texttt{Classrooms}) y se asocia mediante claves foráneas en \texttt{GroupSchedules}, evitando duplicación de texto y facilitando la gestión de cambios.

\subsection{Integridad Referencial y Claves}

\begin{itemize}
  \item Claves primarias (PK): cada tabla tiene un identificador único—natural (\texttt{code} en \texttt{Subjects}) o sintético (\texttt{id} autoincremental).
  \item Claves foráneas (FK): garantizan que solo existan referencias válidas entre tablas. Se usan restricciones \texttt{ON DELETE CASCADE} o \texttt{SET NULL} según el caso.
  \item Índices únicos y compuestos: se definieron índices en columnas de búsqueda frecuente (p.ej. \texttt{(career\_code, group\_id)}) y en campos \texttt{UNIQUE} para acelerar consultas y mantener la unicidad.
\end{itemize}

\subsection{Implementación en SQLite con Room}

Room abstrae el acceso a SQLite ofreciendo:

\begin{itemize}
  \item DAOs reactivos: operaciones CRUD y consultas basadas en \texttt{Flow<…>}, que simplifican el diseño de interfaces reactivas.
  \item Migraciones y validación de esquemas: Room comprueba en tiempo de compilación el cumplimiento del modelo, reduciendo errores en producción.
  \item Transacciones atómicas: el uso de anotaciones \texttt{@Transaction} asegura consistencia al ejecutar varias operaciones relacionadas.
\end{itemize}

SQLite garantiza propiedades ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad), fundamentales para preservar la integridad de datos en escenarios de concurrencia y fallos inesperados.

\subsection{Conversión de Tipos y Almacenamiento de JSON}

Para adaptar tipos de dominio a representaciones en la base de datos:

\begin{itemize}
  \item Enums a \texttt{String:} \texttt{@TypeConverter} convierte valores de \texttt{SubjectStatus}, \texttt{WeekDay}, \texttt{GroupType} y \texttt{AcademicEventType} a su nombre (\texttt{name()}) y viceversa.
  \item Campos JSON: la columna \texttt{links} en \texttt{SelectedSubjects} almacena objetos JSON serializados, permitiendo extensibilidad (enlaces externos, metadatos) sin alterar el esquema relacional.
\end{itemize}

Este enfoque mantiene el modelo de dominio limpio y desacoplado de la forma de persistencia.

\subsection{Índices y Rendimiento}

Se crearon índices en:

\begin{itemize}
  \item \texttt{career\_code}, \texttt{subject\_code}, \texttt{group\_id}: para acelerar joins en filtros por carrera o materia.
  \item Campos de búsqueda (\texttt{name}, \texttt{full\_name}): índices únicos que optimizan consultas \texttt{LIKE}.
\end{itemize}

Los índices reducen considerablemente el tiempo de respuesta en dispositivos móviles con grandes volúmenes de datos, a costa de un ligero aumento en espacio y tiempo de escritura.

\section{Comparación con la Idea Inicial y Evolución del Proyecto}

En la fase de planteamiento original de TecnoTime se propuso una arquitectura clásica de microservicio:

\begin{itemize}
  \item Backend en NestJS: un servidor Node.js modular, encargado de coordinar la extracción de datos, exponer una API RESTful y orquestar la persistencia.
  \item Web scraping con Axios \& Cheerio: para descargar y parsear los PDFs de horarios desde el portal de la Facultad, centralizando el proceso de extracción en el servidor.
  \item Persistencia en MongoDB + Redis: MongoDB como repositorio NoSQL de documentos semiestructurados, y Redis como capa de cacheo para acelerar consultas repetidas.
\end{itemize}

Esta propuesta inicial ofrecía ventajas teóricas —como delegar toda la lógica de datos en un único punto de control y posibilitar futuras integraciones web—, pero al avanzar en el pre–experimento y las primeras iteraciones se detectaron varias complicaciones:

\begin{itemize}
  \item Dependencias externas complejas: mantener un servidor, monitorear despliegues y gestionar variables de entorno incrementaba la carga operativa.
  \item Inconsistencia en el scraping: cada nuevo cambio en el HTML de la web institucional rompía el scraper en NestJS, generando fallos de sincronización.
  \item Necesidad de conexión constante: la aplicación dependía del backend para todo acceso a horarios, penalizando la experiencia offline de los estudiantes.
  \item Latencia y escalabilidad: ante picos de descarga (inscripciones masivas), Redis podía saturarse y el servidor requería escalado horizontal.
\end{itemize}

Ante estos retos, se adoptó un giro decisivo hacia una solución totalmente móvil y offline–first, donde:

\begin{itemize}
  \item La descarga de PDF se realiza directamente en el dispositivo del usuario.
  \item El parseo y estructuración de datos ocurren in situ utilizando bibliotecas Android (Jsoup para HTML, PDFBox para lectura de PDF).
  \item La persistencia se delega completamente a Room (SQLite), eliminando la necesidad de servidores intermedios.
\end{itemize}

\subsection*{Ventajas de la Migración a Móvil Puro}

\begin{enumerate}
  \item Autonomía y Alta Disponibilidad: el estudiante puede consultar y organizar sus horarios sin depender de red ni servidores externos.
  \item Robustez y Simplicidad Operativa: al reducir la infraestructura a solo la app Android, disminuye la superficie de fallos y los costes de mantenimiento.
  \item Experiencia de Usuario Óptima: interfaz nativa con Jetpack Compose, tiempos de respuesta inmediatos y capacidad de uso en modo avión o en zonas de baja cobertura.
  \item Mantenibilidad Local: toda la lógica de extracción, mapeo y sincronización está contenida en el dispositivo, facilitando pruebas, depuración y despliegues.
\end{enumerate}

\subsection*{Lecciones Aprendidas y Futuras Direcciones}

Este cambio de rumbo reveló varias lecciones clave:

\begin{itemize}
  \item Menos infraestructura = más foco en la UX: al eliminar el backend, el equipo dedicó más tiempo a optimizar la experiencia de la app.
  \item Offline–First como requisito real: en entornos académicos con conectividad irregular, la capacidad offline no es un extra, sino una necesidad fundamental.
  \item Flexibilidad para evolutivos futuros: la arquitectura modular de MVVM y Clean Architecture permite, en el futuro, reintroducir opcionalmente un backend o servicio en la nube (por ejemplo, Firebase) para compartir horarios entre dispositivos o almacenar copias de seguridad centralizadas.
\end{itemize}

En resumen, la evolución de un sistema distribuido con servidor a una solución cliente–único demuestra un enfoque pragmático, centrado en las necesidades reales del usuario universitario y en la simplificación de la cadena de valor tecnológica. Esta trayectoria ha permitido a TecnoTime consolidarse como una aplicación ligera, confiable y preparada para futuras extensiones (sincronización multi–dispositivo, analíticas de uso, colaboración entre estudiantes) sin sacrificar la experiencia básica de gestión de horarios.
