\chapter{MARCO TEÓRICO}
\label{chap:marco-teorico}

Este capítulo establece los fundamentos teóricos y tecnológicos que sustentan el desarrollo de ``TecnoTime''. Se abordan los paradigmas de ingeniería de software móvil moderna, la arquitectura de software escalable, los algoritmos de optimización para la generación de horarios y la integración de inteligencia artificial en el borde (Edge AI). Cada sección vincula los conceptos académicos con las tecnologías específicas implementadas en la solución.

\section{Ingeniería de Software para Dispositivos Móviles}
\label{sec:ingenieria-movil}

El desarrollo de aplicaciones móviles ha transitado desde enfoques imperativos hacia paradigmas declarativos y reactivos, priorizando la eficiencia en el manejo de recursos limitados y la experiencia de usuario fluida.

\subsection{Arquitectura de Plataforma Android}
Android es un sistema operativo basado en el núcleo Linux, diseñado para dispositivos con pantalla táctil. Su arquitectura se divide en capas: el kernel de Linux, la capa de abstracción de hardware (HAL), el tiempo de ejecución de Android (ART) y el marco de trabajo de aplicaciones (Application Framework) \cite{android_arch}.

El desarrollo nativo, utilizando el Android SDK (Software Development Kit), permite un acceso directo a las APIs del sistema. Este enfoque ofrece un rendimiento superior en comparación con soluciones híbridas, especialmente en tareas intensivas como la inferencia de modelos de IA \cite{android_programming}.

En este proyecto se utiliza Kotlin, un lenguaje moderno y estáticamente tipado que interopera completamente con Java. Se aprovechan características como Coroutines y Flow para la gestión eficiente de la concurrencia asíncrona.

\subsection{Paradigma de Interfaz Declarativa (Jetpack Compose)}
Tradicionalmente, las interfaces en Android se construían manipulando un árbol de vistas XML (enfoque imperativo). La tendencia actual en la industria, respaldada por estudios comparativos de rendimiento y mantenibilidad \cite{singh2025comparative, jain2023compose}, es el uso de marcos de trabajo declarativos.

El Cuadro \ref{tab:imperative_vs_declarative} resume las diferencias clave entre ambos paradigmas.

\begin{table}[h!]
    \centering
    \begin{tabular}{|p{6cm}|p{6cm}|}
        \hline
        Enfoque Imperativo (XML) & Enfoque Declarativo (Compose) \\
        \hline
        Se manipula manualmente el árbol de vistas (DOM/Views). & La UI se describe como una función del estado. \\
        \hline
        El estado de la UI y el estado de la app pueden desincronizarse. & El estado es la única fuente de verdad. \\
        \hline
        Mucho código repetitivo (boilerplate). & Código más conciso y legible. \\
        \hline
    \end{tabular}
    \caption{Comparación entre UI Imperativa y Declarativa}
    \label{tab:imperative_vs_declarative}
    \small{Fuente: Basado en Singh et al. (2025) \cite{singh2025comparative}}
\end{table}

TecnoTime adopta Jetpack Compose, el kit de herramientas moderno de Android. En este paradigma, la interfaz se describe como una función del estado actual de la aplicación.

Cuando el estado cambia, el marco de trabajo ejecuta un proceso de Recomposición. Este proceso actualiza inteligentemente solo los componentes que dependen de los datos modificados, reduciendo la complejidad de sincronización manual entre la vista y el modelo \cite{gupta2022modern}.

\subsection{Ciclo de Vida y Gestión de Estado (UDF)}
La gestión de estado es crítica en aplicaciones reactivas para garantizar la consistencia de los datos mostrados. Se utiliza el patrón Unidirectional Data Flow (UDF), donde el estado fluye en una sola dirección (de la lógica a la UI) y los eventos fluyen en sentido contrario (de la UI a la lógica).

Para implementar este patrón, se emplean flujos reactivos mediante StateFlow de la librería Kotlin Coroutines. StateFlow es un flujo observable que emite actualizaciones de estado inmutables a la interfaz de usuario, asegurando que la UI siempre refleje el último estado válido producido por la capa de lógica de negocio \cite{reactive_kotlin}.

\section{Arquitectura de Software}
\label{sec:arquitectura-software}

Para garantizar la mantenibilidad, testabilidad y escalabilidad del proyecto, se siguen principios de diseño robustos y patrones arquitectónicos estandarizados en la industria del software.

\subsection{Clean Architecture y Regla de Dependencia}
El proyecto implementa Clean Architecture, propuesta por Robert C. Martin \cite{martin2017-cleanarch}. Esta arquitectura estructura el código en capas concéntricas con responsabilidades claras, como se ilustra en la Figura \ref{fig:clean_architecture}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\textwidth]{images/CleanArchitecture.jpg}
    \caption{Diagrama conceptual de Clean Architecture}
    \label{fig:clean_architecture}
    \small{Fuente: Martin (2012) \cite{martin2012cleanarch_blog}}
\end{figure}


Las capas principales son:
\begin{itemize}
    \item Capa de Dominio (Domain): Contiene la lógica de negocio pura (Entidades y Casos de Uso). Es la capa más interna y no tiene dependencias de frameworks externos.
    \item Capa de Datos (Data): Implementa las interfaces definidas por el dominio y gestiona las fuentes de datos (base de datos local, red).
    \item Capa de Presentación (Presentation): Contiene la UI y los adaptadores de vista.
\end{itemize}
La Regla de Dependencia establece que las dependencias de código fuente solo pueden apuntar hacia adentro; el dominio no conoce detalles de la base de datos ni de la interfaz de usuario, lo que permite cambiar estas capas externas sin afectar la lógica central.

\subsection{Arquitectura Recomendada para Aplicaciones Android}
Google propone una arquitectura en capas que combina los principios de Clean Architecture con las particularidades del ecosistema Android. Esta arquitectura promueve la separación de responsabilidades y facilita las pruebas unitarias, mejorando la mantenibilidad del código a largo plazo.

La Figura \ref{fig:android_architecture} presenta una vista general de esta arquitectura, mostrando cómo las diferentes capas interactúan entre sí mediante interfaces bien definidas.

El flujo de datos es unidireccional. Los eventos de usuario fluyen desde la UI hacia las capas inferiores, mientras que los datos fluyen en sentido contrario, desde los repositorios hacia la interfaz.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{images/android_app_architecture.png}
    \caption{Arquitectura recomendada para aplicaciones Android}
    \label{fig:android_architecture}
    \small{Fuente: Android Developers \cite{android_guide_architecture}}
\end{figure}

Esta arquitectura se compone de tres capas principales, cada una con responsabilidades específicas:

\begin{itemize}
    \item Capa de UI (User Interface): Responsable de renderizar los datos en la pantalla y capturar las interacciones del usuario. En aplicaciones modernas de Android, utiliza Jetpack Compose para construir interfaces declarativas y reactivas.
\end{itemize}

Los componentes clave de esta capa incluyen:
\begin{itemize}
    \item Composables: Funciones que describen la UI como una función del estado.
    \item ViewModels: Gestionan el estado de la UI y sobreviven a cambios de configuración.
    \item UI State: Representación inmutable del estado actual de la pantalla.
\end{itemize}

La Figura \ref{fig:android_ui_layer} ilustra cómo estos componentes colaboran para mantener la UI sincronizada con el estado de la aplicación.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/android_ui_layer.png}
    \caption{Componentes de la capa de UI en Android}
    \label{fig:android_ui_layer}
    \small{Fuente: Android Developers \cite{android_guide_architecture}}
\end{figure}

\begin{itemize}
    \item Capa de Dominio: Opcional pero altamente recomendada en aplicaciones complejas. Su propósito es encapsular la lógica de negocio que puede ser reutilizada por múltiples ViewModels, evitando duplicación de código.
\end{itemize}

Los casos de uso (Use Cases) son el componente principal de esta capa. Cada caso de uso representa una acción específica del usuario (por ejemplo, "Generar Horario" o "Exportar a PDF") y orquesta la interacción entre múltiples repositorios si es necesario.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{images/android_domain_layer.png}
    \caption{Capa de dominio y casos de uso}
    \label{fig:android_domain_layer}
    \small{Fuente: Android Developers \cite{android_guide_architecture}}
\end{figure}

Como se observa en la Figura \ref{fig:android_domain_layer}, los casos de uso actúan como intermediarios entre los ViewModels y los repositorios, simplificando la lógica de presentación.

\begin{itemize}
    \item Capa de Datos: Fuente única de verdad (Single Source of Truth) de la aplicación. Expone los datos a través de repositorios, que pueden combinar información de múltiples fuentes: bases de datos locales, APIs remotas, o archivos del sistema.
\end{itemize}

Los repositorios implementan la lógica de sincronización, caché y transformación de datos. En aplicaciones offline-first como TecnoTime, los repositorios priorizan la base de datos local y sincronizan con fuentes remotas en segundo plano.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/android_data_layer.png}
    \caption{Capa de datos y repositorios en Android}
    \label{fig:android_data_layer}
    \small{Fuente: Android Developers \cite{android_guide_architecture}}
\end{figure}

La Figura \ref{fig:android_data_layer} muestra cómo los repositorios abstraen las fuentes de datos subyacentes, permitiendo cambiar la implementación (por ejemplo, de SQLite a Room) sin afectar las capas superiores.



\subsection{Patrón Model-View-ViewModel (MVVM)}
Se utiliza el patrón MVVM para separar la lógica de presentación de la interfaz de usuario. La Figura \ref{fig:mvvm_pattern} muestra la interacción entre sus componentes.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\textwidth]{images/viewmodel-lifecycle.png}
    \caption{Ciclo de vida del ViewModel en Android}
    \label{fig:mvvm_pattern}
    \small{Fuente: Android Developers \cite{android_viewmodel_guide}}
\end{figure}




\begin{itemize}
    \item Model: Representa los datos y la lógica de negocio (Capa de Dominio).
    \item View: La interfaz de usuario (Compose) que observa el estado.
    \item ViewModel: Actúa como intermediario, exponiendo el estado de la UI y procesando las interacciones del usuario. En Android, los ViewModels están diseñados para sobrevivir a cambios de configuración, como la rotación de pantalla \cite{pro_android_kotlin}.
\end{itemize}

\subsection{Inyección de Dependencias (Hilt)}
La Inyección de Dependencias (DI) es un patrón de diseño donde los objetos reciben sus dependencias desde fuera en lugar de crearlas ellos mismos, promoviendo la Inversión de Control (IoC) \cite{dependency_injection_principles}.

Se utiliza Hilt, la solución estándar de Google para DI en Android basada en Dagger. Hilt reduce el código repetitivo y gestiona el ciclo de vida de los componentes, facilitando la modularidad y permitiendo el intercambio de implementaciones. Por ejemplo, permite inyectar repositorios simulados durante las pruebas automatizadas.

\section{Algoritmia de Planificación (Timetabling)}
\label{sec:algoritmia}

El núcleo funcional de la aplicación aborda el problema de generación de horarios académicos, conocido formalmente en la literatura como University Course Timetabling Problem (UCTP).

\subsection{Problema de Satisfacción de Restricciones (CSP)}
El UCTP se modela matemáticamente como un Problema de Satisfacción de Restricciones (CSP), definido por Russell y Norvig \cite{russell2021ai} como una terna $(X, D, C)$:
\begin{itemize}
    \item $X$: Un conjunto de variables (las asignaturas a inscribir).
    \item $D$: Un conjunto de dominios (los grupos disponibles para cada asignatura).
    \item $C$: Un conjunto de restricciones que especifican combinaciones permitidas de valores.
\end{itemize}

Las restricciones se clasifican en Duras (Hard), que deben cumplirse obligatoriamente (por ejemplo, no solapamiento de horarios), y Blandas (Soft), que expresan preferencias deseables pero no obligatorias (por ejemplo, minimizar huecos libres).

\subsection{Algoritmos de Búsqueda: Backtracking}
Para resolver el CSP, se implementa el algoritmo de Backtracking (Vuelta Atrás). Este es un algoritmo de búsqueda en profundidad que construye candidatos a solución de manera incremental. Si se añade una asignación que viola una restricción dura, el algoritmo retrocede al paso anterior y prueba con el siguiente valor del dominio, descartando esa rama del árbol de búsqueda \cite{cormen_algorithms}.

\subsection{Heurísticas de Poda y Optimización}
Dado que el espacio de búsqueda puede crecer exponencialmente, se aplican heurísticas para mejorar la eficiencia:
\begin{itemize}
    \item Poda (Pruning): Se descartan tempranamente las ramas que no pueden llevar a una solución válida. Por ejemplo, si una materia obligatoria se queda sin cupos válidos.
    \item Ordenamiento de Variables (Fail-First): Se intentan asignar primero las variables más restrictivas para detectar conflictos lo antes posible \cite{automated_timetabling}.
    \item Función Objetivo: Las soluciones válidas encontradas se evalúan mediante una función de puntuación ponderada que penaliza los huecos y bonifica la asignación de docentes preferidos.
\end{itemize}

\section{Inteligencia Artificial en Dispositivos Móviles (Edge AI)}
\label{sec:edge-ai}

``TecnoTime'' integra capacidades de inteligencia artificial generativa ejecutándose directamente en el dispositivo móvil, un paradigma conocido como Edge AI.

\subsection{Inferencia Local vs. Inferencia en la Nube}
A diferencia de la IA en la nube, la Edge AI procesa los datos localmente en el dispositivo del usuario. El Cuadro \ref{tab:edge_vs_cloud} compara ambos enfoques.

\begin{table}[h!]
    \centering
    \begin{tabular}{|p{5cm}|p{5cm}|}
        \hline
        Edge AI (Local) & Cloud AI (Nube) \\
        \hline
        Procesamiento en el dispositivo. & Procesamiento en servidores remotos. \\
        \hline
        Privacidad total (datos no salen). & Riesgo de privacidad al enviar datos. \\
        \hline
        Latencia baja (tiempo real). & Latencia depende de la red. \\
        \hline
        Funciona sin internet (Offline). & Requiere conexión constante. \\
        \hline
    \end{tabular}
    \caption{Comparación entre Edge AI y Cloud AI}
    \label{tab:edge_vs_cloud}
    \small{Fuente: Basado en Pothineni (2024) \cite{pothineni2024offline} y Shi et al. (2023) \cite{edge_ai_arxiv}}
\end{table}

En la implementación, se utiliza la librería llama.cpp a través de JNI (Java Native Interface) para ejecutar la inferencia de modelos de lenguaje de manera eficiente en la CPU del dispositivo Android.

\subsection{Modelos de Lenguaje (LLMs) y Cuantización}
Para viabilizar la ejecución de Large Language Models (LLMs) en dispositivos con recursos limitados (memoria y batería), se utiliza la técnica de Cuantización. Este proceso reduce la precisión de los pesos del modelo (por ejemplo, de punto flotante de 16 bits a enteros de 4 bits), disminuyendo drásticamente el tamaño del modelo y el consumo de memoria con una pérdida mínima de precisión \cite{quantization_papers}. El formato de archivo utilizado es GGUF, optimizado para inferencia rápida en CPU.

\section{Gestión y Persistencia de Datos}
\label{sec:persistencia}

La aplicación sigue una filosofía Offline-First, garantizando que la funcionalidad principal esté disponible sin conexión a internet, un requisito crítico en entornos con conectividad intermitente \cite{guda2025offline}.

\subsection{Bases de Datos Relacionales Embebidas (Room)}
Para la persistencia local se utiliza SQLite, un motor de base de datos relacional ligero embebido en Android. El acceso se gestiona a través de la librería Room, que proporciona una capa de abstracción orientada a objetos sobre SQLite, permitiendo definir Entidades y DAOs con verificación de consultas SQL en tiempo de compilación \cite{database_concepts}.

\subsection{Estrategias de Sincronización y Offline-First}
El patrón Offline-First invierte la dependencia tradicional de las aplicaciones móviles respecto a la conectividad de red. En lugar de asumir que la red siempre está disponible, este enfoque trata la conectividad como un recurso opcional y potencialmente intermitente.

La Figura \ref{fig:offline_architecture} ilustra la arquitectura típica de una aplicación que sigue este patrón. Como se observa, la base de datos local actúa como la fuente primaria de datos, mientras que las operaciones de red se ejecutan de manera asíncrona en segundo plano.

En la implementación de TecnoTime, la arquitectura adopta el principio de Single Source of Truth (SSOT). La interfaz de usuario siempre observa y muestra los datos de la base de datos local, garantizando una experiencia fluida incluso sin conexión.

Las operaciones de red para actualizar los horarios se ejecutan en segundo plano utilizando WorkManager, un componente que actúa como planificador de tareas diferibles y garantizadas.

Cuando la sincronización completa exitosamente, se actualiza la base de datos local. Room notifica automáticamente a la UI mediante flujos reactivos (Flow) para que refleje los cambios. Este diseño desacopla la experiencia de usuario de la latencia de la red, permitiendo que la aplicación funcione de manera óptima tanto en conexiones lentas como en ausencia total de conectividad.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{images/offline_architecture_couchbase.png}
    \caption{Arquitectura típica de una aplicación Offline-First}
    \label{fig:offline_architecture}
    \small{Fuente: Couchbase Inc. (2023) \cite{couchbase_offlinefirst}}
\end{figure}

