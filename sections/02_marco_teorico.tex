\chapter{MARCO TEÓRICO}
\label{chap:marco-teorico}

Este capítulo establece los fundamentos teóricos y tecnológicos relacionados con la ingeniería de software móvil moderna, la arquitectura de software escalable, los algoritmos de optimización y la inteligencia artificial en el borde (Edge AI).

\section{Ingeniería de Software para Dispositivos Móviles}
\label{sec:ingenieria-movil}

El desarrollo de aplicaciones móviles ha transitado desde enfoques imperativos hacia paradigmas declarativos y reactivos. Este cambio prioriza la eficiencia en el manejo de recursos limitados y asegura una interacción continua con el usuario.

\subsection{Arquitectura de Plataforma Android}
Android es un sistema operativo basado en el núcleo Linux, diseñado para dispositivos con pantalla táctil. Su arquitectura se divide en capas: el kernel de Linux, la capa de abstracción de hardware (HAL), el tiempo de ejecución de Android (ART) y el marco de trabajo de aplicaciones (Application Framework) \cite{android_arch}.

El desarrollo nativo, utilizando el Android SDK (Software Development Kit), permite un acceso directo a las APIs del sistema. En consecuencia, este enfoque proporciona un rendimiento optimizado en comparación con soluciones híbridas, aspecto relevante en tareas intensivas como la inferencia de modelos de IA \cite{android_programming}.

Kotlin es un lenguaje moderno y estáticamente tipado que interopera completamente con Java, ofreciendo características como Coroutines y Flow para la gestión eficiente de la concurrencia asíncrona.

\subsection{Paradigma de Interfaz Declarativa (Jetpack Compose)}
Tradicionalmente, las interfaces en Android se construían manipulando un árbol de vistas XML (enfoque imperativo). Actualmente, el uso de marcos de trabajo declarativos se ha consolidado en la industria, respaldado por estudios comparativos de rendimiento y mantenibilidad \cite{singh2025comparative, jain2023compose}.

El Cuadro \ref{tab:imperative_vs_declarative} resume las diferencias clave entre ambos paradigmas.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{6cm}|p{6cm}|}
        \hline
        Enfoque Imperativo (XML) & Enfoque Declarativo (Compose) \\
        \hline
        Se manipula manualmente el árbol de vistas (DOM/Views). & La UI se describe como una función del estado. \\
        \hline
        El estado de la UI y el estado de la app pueden desincronizarse. & El estado es la única fuente de verdad. \\
        \hline
        Código redundante (boilerplate). & Código conciso y legible. \\
        \hline
    \end{tabular}
    \caption{Comparación entre UI Imperativa y Declarativa}
    \label{tab:imperative_vs_declarative}
    \small{Fuente: Basado en Singh et al. (2025) \cite{singh2025comparative}}
\end{table}

Jetpack Compose es el kit de herramientas moderno de Android para construir interfaces nativas. En este paradigma, la interfaz se describe como una función del estado actual de la aplicación.


Cuando el estado cambia, el marco de trabajo ejecuta un proceso de Recomposición. Este proceso actualiza selectivamente los componentes que dependen de los datos modificados. De esta forma, se reduce la complejidad de sincronización manual entre la vista y el modelo \cite{gupta2022modern}.

\subsection{Ciclo de Vida y Gestión de Estado (UDF)}
La gestión de estado es crítica en aplicaciones reactivas para garantizar la consistencia de los datos mostrados. Se utiliza el patrón Unidirectional Data Flow (UDF), donde el estado fluye en una sola dirección (de la lógica a la UI) y los eventos fluyen en sentido contrario (de la UI a la lógica).

Para implementar este patrón, se emplean flujos reactivos mediante StateFlow de la librería Kotlin Coroutines. StateFlow es un flujo observable que emite actualizaciones de estado inmutables a la interfaz de usuario. Por lo tanto, se garantiza que la interfaz refleje el último estado válido producido por la capa de lógica de negocio \cite{reactive_kotlin}.

\section{Arquitectura de Software}
\label{sec:arquitectura-software}

Para garantizar la mantenibilidad, testabilidad y escalabilidad del software, se siguen principios de diseño robustos y patrones arquitectónicos estandarizados en la industria.

\subsection{Clean Architecture y Regla de Dependencia}
Clean Architecture, propuesta por Robert C. Martin \cite{martin2017-cleanarch}, estructura el código en capas concéntricas con responsabilidades claras, como se ilustra en la Figura \ref{fig:clean_architecture}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{images/CleanArchitecture.jpg}
    \caption{Diagrama conceptual de Clean Architecture}
    \label{fig:clean_architecture}
    \small{Fuente: Martin (2012) \cite{martin2012cleanarch_blog}}
\end{figure}


Las capas principales son:
\begin{itemize}
    \item Capa de Dominio (Domain): Contiene la lógica de negocio pura (Entidades y Casos de Uso). Es la capa más interna y no tiene dependencias de frameworks externos.
    \item Capa de Datos (Data): Implementa las interfaces definidas por el dominio y gestiona las fuentes de datos (base de datos local, red).
    \item Capa de Presentación (Presentation): Contiene la UI y los adaptadores de vista.
\end{itemize}
La Regla de Dependencia establece que las dependencias de código fuente solo pueden apuntar hacia adentro; el dominio no conoce detalles de la base de datos ni de la interfaz de usuario, lo que permite cambiar estas capas externas sin afectar la lógica central.

\subsection{Arquitectura Recomendada para Aplicaciones Android}
Google propone una arquitectura en capas que combina los principios de Clean Architecture con las particularidades del ecosistema Android. Esta arquitectura promueve la separación de responsabilidades y facilita las pruebas unitarias, mejorando la mantenibilidad del código a largo plazo.

La Figura \ref{fig:android_architecture} presenta una vista general de esta arquitectura, mostrando cómo las diferentes capas interactúan entre sí mediante interfaces bien definidas.

El flujo de datos es unidireccional. Los eventos de usuario fluyen desde la UI hacia las capas inferiores, mientras que los datos fluyen en sentido contrario, desde los repositorios hacia la interfaz.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.55\textwidth]{images/android_app_architecture.png}
    \caption{Arquitectura recomendada para aplicaciones Android}
    \label{fig:android_architecture}
    \small{Fuente: Android Developers \cite{android_guide_architecture}}
\end{figure}

Esta arquitectura se compone de tres capas principales, cada una con responsabilidades específicas:

\begin{enumerate}
    \item \textbf{Capa de UI (User Interface)}

    Responsable de renderizar los datos en la pantalla y capturar las interacciones del usuario. En aplicaciones modernas de Android, utiliza Jetpack Compose para construir interfaces declarativas y reactivas.

Los componentes clave de esta capa incluyen:
\begin{itemize}
    \item Composables: Funciones que describen la UI como una función del estado.
    \item ViewModels: Gestionan el estado de la UI y sobreviven a cambios de configuración.
    \item UI State: Representación inmutable del estado actual de la pantalla.
\end{itemize}

La Figura \ref{fig:android_ui_layer} ilustra cómo estos componentes colaboran para mantener la UI sincronizada con el estado de la aplicación.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{images/udf_cycle.png}
    \caption{Ciclo de eventos y datos en el patrón UDF}
    \label{fig:android_ui_layer}
    \small{Fuente: Android Developers \cite{android_ui_layer_guide}}
\end{figure}

    \item \textbf{Capa de Dominio}

    Opcional pero altamente recomendada en aplicaciones complejas. Su propósito es encapsular la lógica de negocio que puede ser reutilizada por múltiples ViewModels, evitando duplicación de código.

Los casos de uso (Use Cases) son el componente principal de esta capa. Cada caso de uso representa una acción específica del usuario (por ejemplo, "Generar Horario" o "Exportar a PDF") y orquesta la interacción entre múltiples repositorios si es necesario.

Los casos de uso actúan como intermediarios entre los ViewModels y los repositorios, simplificando la lógica de presentación al encapsular reglas de negocio complejas y reutilizables.

    \item \textbf{Capa de Datos}

    Fuente única de verdad (Single Source of Truth) de la aplicación. Expone los datos a través de repositorios, que pueden combinar información de múltiples fuentes: bases de datos locales, APIs remotas, o archivos del sistema.

Los repositorios implementan la lógica de sincronización, caché y transformación de datos. En aplicaciones offline-first, los repositorios priorizan la base de datos local y sincronizan con fuentes remotas en segundo plano.

La Figura \ref{fig:android_data_layer} muestra cómo los repositorios abstraen las fuentes de datos subyacentes, permitiendo cambiar la implementación (por ejemplo, de SQLite a Room) sin afectar las capas superiores.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/data_layer_diagram.png}
    \caption{Capa de datos y repositorios en Android}
    \label{fig:android_data_layer}
    \small{Fuente: Android Developers \cite{android_data_layer_guide}}
\end{figure}

\end{enumerate}



\subsection{Patrón Model-View-ViewModel (MVVM)}
El patrón MVVM (Model-View-ViewModel) se utiliza para separar la lógica de presentación de la interfaz de usuario. La Figura \ref{fig:mvvm_pattern} muestra la interacción entre sus componentes.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{images/viewmodel-lifecycle.png}
    \caption{Ciclo de vida del ViewModel en Android}
    \label{fig:mvvm_pattern}
    \small{Fuente: Android Developers \cite{android_viewmodel_guide}}
\end{figure}




\begin{itemize}
    \item Model: Representa los datos y la lógica de negocio (Capa de Dominio).
    \item View: La interfaz de usuario (Compose) que observa el estado.
    \item ViewModel: Actúa como intermediario, exponiendo el estado de la UI y procesando las interacciones del usuario. En Android, los ViewModels están diseñados para sobrevivir a cambios de configuración, como la rotación de pantalla \cite{pro_android_kotlin}.
\end{itemize}

\subsection{Inyección de Dependencias (Hilt)}
La Inyección de Dependencias (DI) es un patrón de diseño donde los objetos reciben sus dependencias desde fuera en lugar de crearlas ellos mismos, promoviendo la Inversión de Control (IoC) \cite{dependency_injection_principles}.

Hilt es la solución estándar de Google para DI en Android basada en Dagger. Reduce el código repetitivo y gestiona el ciclo de vida de los componentes, facilitando la modularidad y permitiendo el intercambio de implementaciones. Por ejemplo, permite inyectar repositorios simulados durante las pruebas automatizadas.

\section{Fundamentos Algorítmicos y de Optimización}
\label{sec:algoritmia}

El problema de generación de horarios académicos es conocido formalmente en la literatura como University Course Timetabling Problem (UCTP). Este problema se aborda mediante diversas teorías y algoritmos de optimización.

\subsection{Teoría de Grafos en la Planificación}
La Teoría de Grafos proporciona un marco matemático robusto para modelar conflictos en problemas de planificación. El problema de horarios se puede representar como un problema de coloración de grafos (Graph Coloring Problem - GCP) \cite{lewis2015guide}.

En este modelo:
\begin{itemize}
    \item Vértices (Nodos): Representan los eventos o clases a programar.
    \item Aristas (Enlaces): Conectan dos vértices si existe un conflicto entre ellos (por ejemplo, mismo profesor, mismo grupo de estudiantes o misma aula).
    \item Colores: Representan los periodos de tiempo disponibles.
\end{itemize}

El objetivo es asignar un color a cada vértice de tal manera que ningunos dos vértices adyacentes compartan el mismo color, utilizando el mínimo número de colores posible (número cromático).

Algoritmos clásicos como Welsh-Powell o DSATUR (Degree of Saturation) son eficientes para encontrar soluciones en grafos de conflictos \cite{burke2004-state}. No obstante, las restricciones inherentes a la planificación académica (preferencias de docentes, minimización de huecos, restricciones de capacidad) limitan la aplicabilidad directa del modelo de coloración pura.

Por esta razón, aunque la teoría de grafos fundamenta el entendimiento de los conflictos, un enfoque alternativo y flexible es el uso de CSP y Backtracking.

\subsection{Problema de Satisfacción de Restricciones (CSP)}
El UCTP se modela matemáticamente como un Problema de Satisfacción de Restricciones (CSP), definido por Russell y Norvig \cite{russell2021ai} como una terna $(X, D, C)$:
\begin{itemize}
    \item $X$: Un conjunto de variables (las asignaturas a inscribir).
    \item $D$: Un conjunto de dominios (los grupos disponibles para cada asignatura).
    \item $C$: Un conjunto de restricciones que especifican combinaciones permitidas de valores.
\end{itemize}

Las restricciones se clasifican en Duras (Hard), que deben cumplirse obligatoriamente (por ejemplo, no solapamiento de horarios), y Blandas (Soft), que expresan preferencias deseables pero no obligatorias (por ejemplo, minimizar huecos libres).

\subsection{Algoritmos de Búsqueda y Backtracking}
Para resolver problemas de tipo CSP, comúnmente se utiliza el algoritmo de Backtracking (Vuelta Atrás). Este método realiza una búsqueda sistemática en el espacio de soluciones:

\begin{enumerate}
    \item Generación de Candidatos: El algoritmo construye soluciones de manera incremental, asignatura por asignatura.
    \item Verificación de Restricciones: En cada paso, verifica si la asignación actual viola alguna restricción dura.
    \item Retroceso (Backtrack): Si se encuentra un conflicto insalvable, el algoritmo retrocede al paso anterior y prueba con el siguiente grupo disponible, descartando la rama actual del árbol de búsqueda \cite{cormen_algorithms}.
\end{enumerate}

Este enfoque permite identificar el conjunto completo de combinaciones válidas posibles. Dicha característica resulta fundamental para presentar al estudiante todas las opciones disponibles.

\subsection{Optimización Combinatoria y Selección}
Dado que el número de combinaciones válidas puede ser muy grande, se aplica un proceso de Optimización Combinatoria para seleccionar las mejores opciones. Los algoritmos de optimización no solo buscan una solución factible, sino que buscan las "mejores $k$" soluciones según criterios de calidad.

Se suele utilizar un sistema de ranking donde cada horario generado recibe una puntuación basada en el cumplimiento de restricciones blandas. Posteriormente, se ordenan las soluciones de mayor a menor puntaje y se presentan al usuario las opciones destacadas, facilitando el proceso de selección.

\subsection{Análisis de Decisión Multi-criterio (MCDA)}
Para evaluar la calidad de un horario, se emplea el Análisis de Decisión Multi-criterio (MCDA). Este enfoque permite considerar múltiples factores simultáneamente, asignando pesos específicos a cada criterio \cite{triantaphyllou2000multi}.

En la práctica, esto se puede implementar a través del Patrón de Diseño \textit{Strategy}. Este patrón permite cambiar dinámicamente la estrategia de evaluación (por ejemplo, "Priorizar mañanas libres", "Minimizar huecos", "Evitar cruces de materias"), calculando el puntaje total como una suma ponderada de estos criterios. Esto otorga flexibilidad para adaptarse a las preferencias cambiantes.

\section{Inteligencia Artificial en Dispositivos Móviles (Edge AI)}
\label{sec:edge-ai}

La Inteligencia Artificial en el Borde (Edge AI) permite integrar capacidades de inteligencia artificial generativa ejecutándose directamente en el dispositivo móvil.

\subsection{Inferencia Local vs. Inferencia en la Nube}
A diferencia de la IA en la nube, la Edge AI procesa los datos localmente en el dispositivo del usuario. El Cuadro \ref{tab:edge_vs_cloud} compara ambos enfoques.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{5cm}|p{5cm}|}
        \hline
        Edge AI (Local) & Cloud AI (Nube) \\
        \hline
        Procesamiento en el dispositivo. & Procesamiento en servidores remotos. \\
        \hline
        Privacidad total (datos no salen). & Riesgo de privacidad al enviar datos. \\
        \hline
        Latencia baja (tiempo real). & Latencia depende de la red. \\
        \hline
        Funciona sin internet (Offline). & Requiere conexión constante. \\
        \hline
    \end{tabular}
    \caption{Comparación entre Edge AI y Cloud AI}
    \label{tab:edge_vs_cloud}
    \small{Fuente: Basado en Pothineni (2024) \cite{pothineni2024offline} y Shi et al. (2023) \cite{edge_ai_arxiv}}
\end{table}

Librerías como llama.cpp permiten ejecutar la inferencia de modelos de lenguaje de manera eficiente en la CPU de dispositivos Android a través de JNI (Java Native Interface).

\subsection{Modelos de Lenguaje (LLMs) y Cuantización}
Para viabilizar la ejecución de Large Language Models (LLMs) en dispositivos con recursos limitados (memoria y batería), se utiliza la técnica de Cuantización. Este proceso reduce la precisión de los pesos del modelo (por ejemplo, de punto flotante de 16 bits a enteros de 4 bits), disminuyendo drásticamente el tamaño del modelo y el consumo de memoria con una pérdida mínima de precisión \cite{quantization_papers}. El formato de archivo utilizado es GGUF, optimizado para inferencia rápida en CPU.

\section{Gestión y Persistencia de Datos}
\label{sec:persistencia}

La filosofía Offline-First garantiza que la funcionalidad principal esté disponible sin conexión a internet, un requisito crítico en entornos con conectividad intermitente \cite{guda2025offline}.

\subsection{Bases de Datos Relacionales Embebidas (Room)}
SQLite es un motor de base de datos relacional ligero embebido en Android. Room proporciona una capa de abstracción orientada a objetos sobre SQLite, permitiendo definir Entidades y DAOs con verificación de consultas SQL en tiempo de compilación \cite{database_concepts}.

\subsection{Estrategias de Sincronización y Offline-First}
El patrón Offline-First invierte la dependencia tradicional de las aplicaciones móviles respecto a la conectividad de red. En lugar de asumir que la red siempre está disponible, este enfoque trata la conectividad como un recurso opcional y potencialmente intermitente.

La Figura \ref{fig:offline_architecture} ilustra la arquitectura típica de una aplicación que sigue este patrón. Como se observa, la base de datos local actúa como la fuente primaria de datos, mientras que las operaciones de red se ejecutan de manera asíncrona en segundo plano.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{images/offline_architecture_couchbase.png}
    \caption{Arquitectura típica de una aplicación Offline-First}
    \label{fig:offline_architecture}
    \small{Fuente: Couchbase Inc. (2023) \cite{couchbase_offlinefirst}}
\end{figure}

En una arquitectura Offline-First robusta, se adopta el principio de Single Source of Truth (SSOT). La interfaz de usuario observa y muestra los datos de la base de datos local, permitiendo la operatividad incluso sin conexión.

Las operaciones de red pueden ejecutarse en segundo plano utilizando componentes como WorkManager, que actúa como planificador de tareas diferibles y garantizadas.

Cuando la sincronización completa exitosamente, se actualiza la base de datos local. Las librerías de persistencia modernas notifican automáticamente a la UI mediante flujos reactivos para que refleje los cambios. Este diseño desacopla la interacción del usuario de la latencia de la red, permitiendo que la aplicación mantenga su funcionalidad tanto en conexiones lentas como en ausencia total de conectividad.

\section{Notificaciones y Widgets en Android}
\label{sec:notificaciones-widgets}

Las aplicaciones móviles modernas requieren mecanismos para interactuar con el usuario incluso cuando no están en primer plano. Android proporciona componentes específicos para este propósito: Notificaciones y App Widgets.

\subsection{Sistema de Notificaciones}
Las notificaciones son mensajes que Android muestra fuera de la interfaz de usuario de la aplicación para proporcionar recordatorios, comunicaciones de otras personas u otra información oportuna de la aplicación \cite{android_notifications}.

A partir de Android 8.0 (API nivel 26), todas las notificaciones deben asignarse a un Canal de Notificación (Notification Channel). Esto permite agrupar las notificaciones por tipo (por ejemplo, "Recordatorios de Clases", "Avisos Generales") y facilita la gestión de la configuración de cada canal, como el sonido, la vibración y la importancia, sin tener que bloquear todas las notificaciones de la aplicación \cite{android_notification_channels}.

La Importancia de la notificación determina cuánto interrumpe al usuario (visual y auditivamente). Los niveles van desde "Urgente" (sonido y ventana emergente) hasta "Baja" (sin sonido ni interrupción visual).

Existen dos tipos principales de implementación:
\begin{itemize}
    \item Notificaciones Locales: Programadas por la propia aplicación utilizando \texttt{AlarmManager} o \texttt{WorkManager}. Son ideales para recordatorios basados en el tiempo que no requieren conexión a internet, como los recordatorios de clases configurados en el dispositivo.
    \item Notificaciones Remotas (Push): Enviadas desde un servidor externo a través de servicios como Firebase Cloud Messaging (FCM).
\end{itemize}

\subsection{App Widgets}
Los App Widgets son vistas de aplicación en miniatura que se pueden incrustar en otras aplicaciones (como la pantalla de inicio) y recibir actualizaciones periódicas \cite{android_widgets}.

La arquitectura de un Widget se basa en los siguientes componentes clave:
\begin{itemize}
    \item AppWidgetProvider: Una implementación de \texttt{BroadcastReceiver} que maneja el ciclo de vida del widget (actualización, habilitación, inhabilitación y eliminación).
    \item RemoteViews: Debido a que el widget se ejecuta en un proceso distinto al de la aplicación principal (generalmente el proceso del "Launcher"), la interfaz de usuario no se puede manipular directamente. \texttt{RemoteViews} es una clase que describe una jerarquía de vistas que se puede mostrar en otro proceso. Actúa como un conjunto de instrucciones de renderizado que el sistema ejecuta de manera segura \cite{android_remoteviews}.
\end{itemize}

El ciclo de vida de actualización está definido por un intervalo de tiempo en el archivo de configuración XML, aunque también se pueden solicitar actualizaciones manuales cuando ocurren cambios en los datos de la aplicación, garantizando la sincronización de la información visualizada.




