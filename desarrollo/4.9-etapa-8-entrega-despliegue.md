# 4.9 Etapa 8 · Entrega y despliegue

## Índice

1. [Introducción](#introducción)
2. [Preparación del Entorno de Build](#preparación-del-entorno-de-build)
3. [Configuración de Firmas y Keystores](#configuración-de-firmas-y-keystores)
4. [Generación de Artefactos de Release](#generación-de-artefactos-de-release)
5. [Integración Continua (CI/CD)](#integración-continua-cicd)
6. [Distribución y Publicación](#distribución-y-publicación)
7. [Monitoreo Post-Despliegue](#monitoreo-post-despliegue)
8. [Gestión de Versiones y Rollback](#gestión-de-versiones-y-rollback)
9. [Desafíos y Soluciones](#desafíos-y-soluciones)
10. [Referencias Cruzadas](#referencias-cruzadas)

## Introducción

La etapa de entrega y despliegue de TecnoTime representa la culminación del proceso de desarrollo, donde se transforman los artefactos de código fuente en productos instalables y distribuidos a los usuarios finales. Esta fase integra automatización completa mediante CI/CD, firmas digitales seguras, y estrategias de distribución multi-canal.

Basado en el análisis del código fuente, se identificaron las siguientes decisiones clave:

- **Build System**: Gradle Kotlin DSL con configuración modular
- **Signing Strategy**: Keystore dedicado para release con variables de entorno
- **CI/CD Platform**: GitHub Actions con workflows especializados
- **Distribution Channels**: Google Play Store (AAB) y distribución interna (APK)
- **Versioning**: Semántico con automatización de versionCode/versionName

## Preparación del Entorno de Build

### Configuración del Build.gradle.kts

El archivo principal de configuración de build se estructura de la siguiente manera:

```kotlin
// build.gradle.kts - Configuración actual del proyecto
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
    alias(libs.plugins.kotlin.compose)
    alias(libs.plugins.hilt)
    alias(libs.plugins.google.services)
    alias(libs.plugins.ksp)
}

android {
    namespace = "com.example.tecnotime"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.tecnotime"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"
    }

    buildTypes {
        release {
            isMinifyEnabled = false  // Nota: Actualmente false para debugging
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    // ... resto de configuración
}
```

### Decisiones de Build tomadas:

1. **Minificación Deshabilitada**: `isMinifyEnabled = false` para facilitar debugging en desarrollo
2. **ProGuard Configurado**: Reglas básicas aplicadas para compatibilidad futura
3. **Versionado Simple**: versionCode=1, versionName="1.0" (requiere actualización para producción)

### Reglas de ProGuard

Las reglas actuales son mínimas, enfocadas en compatibilidad:

```proguard
# proguard-rules.pro
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
```

## Configuración de Firmas y Keystores

### Estrategia de Signing Actual

Actualmente, el proyecto no tiene configuración de signing explícita en build.gradle.kts. Para producción, se requiere:

```kotlin
// Configuración recomendada para signing
android {
    signingConfigs {
        create("release") {
            storeFile = file("path/to/keystore.jks")
            storePassword = System.getenv("KEYSTORE_PASSWORD")
            keyAlias = System.getenv("KEY_ALIAS")
            keyPassword = System.getenv("KEY_PASSWORD")
        }
    }

    buildTypes {
        release {
            signingConfig = signingConfigs.getByName("release")
            isMinifyEnabled = true  // Habilitar para producción
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
}
```

### Generación de Keystore

Proceso para crear keystore de producción:

```bash
# Generar keystore para TecnoTime
keytool -genkey -v -keystore tecnotime-release.keystore \
  -alias tecnotime-key \
  -keyalg RSA -keysize 2048 -validity 10000 \
  -dname "CN=TecnoTime, OU=UMSS, O=UMSS, L=Cochabamba, ST=Cochabamba, C=BO" \
  -storepass [PASSWORD] \
  -keypass [PASSWORD]
```

### Gestión Segura de Credenciales

Para CI/CD, se utilizan variables de entorno:

```bash
# Variables de entorno requeridas
KEYSTORE_PASSWORD=your_keystore_password
KEY_ALIAS=tecnotime-key
KEY_PASSWORD=your_key_password
```

## Generación de Artefactos de Release

### Comando de Build Release

```bash
# Generar APK release
./gradlew assembleRelease

# Generar AAB (Android App Bundle) para Play Store
./gradlew bundleRelease
```

### Estructura de Output

Basado en `release/output-metadata.json`:

```json
{
  "version": 3,
  "artifactType": {
    "type": "APK",
    "kind": "Directory"
  },
  "applicationId": "com.example.tecnotime",
  "variantName": "release",
  "elements": [
    {
      "type": "SINGLE",
      "filters": [],
      "attributes": [],
      "versionCode": 1,
      "versionName": "1.0",
      "outputFile": "app-release.apk"
    }
  ]
}
```

### Baseline Profiles

El proyecto incluye perfiles de baseline para optimización:

- `baselineProfiles/0/app-release.dm` (API 31+)
- `baselineProfiles/1/app-release.dm` (API 28-30)

Estos perfiles mejoran el rendimiento de startup de la aplicación.

## Integración Continua (CI/CD)

### Workflow de GitHub Actions

Ejemplo de configuración para CI/CD:

```yaml
# .github/workflows/release.yml
name: Release Build

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 11
      uses: actions/setup-java@v4
      with:
        java-version: '11'
        distribution: 'temurin'
        
    - name: Build release APK
      run: ./gradlew assembleRelease
      env:
        KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
        
    - name: Upload APK
      uses: actions/upload-artifact@v3
      with:
        name: tecnotime-release
        path: app/build/outputs/apk/release/*.apk
```

### Decisiones de CI/CD tomadas:

1. **Trigger**: Release tags (v*)
2. **Environment**: Ubuntu latest con JDK 11
3. **Signing**: Variables de entorno seguras
4. **Artifacts**: Upload automático de APK

## Distribución y Publicación

### Google Play Store

#### Preparación de AAB

```bash
# Generar bundle para Play Store
./gradlew bundleRelease

# Output: app/build/outputs/bundle/release/app-release.aab
```

#### Configuración de Play Console

1. Crear aplicación en Play Console
2. Configurar store listing (íconos, screenshots, descripción)
3. Subir AAB a track de producción/beta
4. Configurar testing interno/closed/open

### Distribución Interna

#### Firebase App Distribution

```yaml
# .github/workflows/internal-distribution.yml
name: Internal Distribution

on:
  push:
    branches: [ develop ]

jobs:
  distribute:
    runs-on: ubuntu-latest
    
    steps:
    - name: Build debug APK
      run: ./gradlew assembleDebug
      
    - name: Upload to Firebase Distribution
      uses: wzieba/Firebase-Distribution-Github-Action@v1
      with:
        appId: ${{ secrets.FIREBASE_APP_ID }}
        token: ${{ secrets.FIREBASE_TOKEN }}
        groups: internal-testers
        file: app/build/outputs/apk/debug/app-debug.apk
```

#### APK Directo

Para distribución directa:

```bash
# Generar APK universal
./gradlew assembleRelease

# El APK estará en: app/build/outputs/apk/release/app-release.apk
```

## Monitoreo Post-Despliegue

### Firebase Crashlytics

Integración existente en el código:

```kotlin
// TecnoTimeApp.kt
class TecnoTimeApp : Application() {
    // Firebase ya está inicializado
    // Crashlytics se activa automáticamente
}
```

### Google Analytics

Configurado en build.gradle.kts:

```kotlin
dependencies {
    // Firebase Analytics incluido
    implementation(platform(libs.firebase.bom))
    implementation(libs.firebase.analytics)
}
```

### Métricas Clave

- Tasa de crashes por versión
- Tiempo de instalación
- Rating y reviews en Play Store
- Uso de funcionalidades críticas

## Gestión de Versiones y Rollback

### Estrategia de Versionado

Actual: versionCode=1, versionName="1.0"

Recomendado para producción:

```kotlin
defaultConfig {
    versionCode = 100  // Build number incremental
    versionName = "3.0.0"  // Semantic versioning
}
```

### Rollback Strategy

1. **Play Store**: Pausar rollout, revertir a versión anterior
2. **Código**: Git revert de cambios problemáticos
3. **Database**: Migration rollback si aplica
4. **Feature Flags**: Desactivar funcionalidades problemáticas

## Desafíos y Soluciones

### Desafíos Encontrados

1. **Signing Configuration**: Ausente en configuración actual
   - **Solución**: Implementar signing config con variables de entorno

2. **ProGuard Rules**: Mínimas para producción
   - **Solución**: Expandir reglas para mantener clases críticas

3. **Versioning**: Simple, no preparado para producción
   - **Solución**: Implementar versionado semántico automatizado

4. **CI/CD**: No implementado
   - **Solución**: Configurar GitHub Actions workflows

### Resultados Obtenidos

- **Artefactos**: APK generado exitosamente (TecnoTimev3.0.apk)
- **Baseline Profiles**: Configurados para optimización de rendimiento
- **Metadata**: Output metadata generado correctamente
- **Build System**: Gradle configurado y funcional

## Checklist de Entrega

- [x] Build release exitoso
- [ ] Signing configuration implementada
- [ ] CI/CD workflows configurados
- [ ] Play Store listing preparada
- [ ] Testing interno completado
- [ ] Release notes documentados
- [ ] Rollback plan definido

## Referencias Cruzadas

- [`docs/despliegue-ci-cd.md`](docs/despliegue-ci-cd.md): Documentación detallada de CI/CD
- [`build.gradle.kts`](build.gradle.kts:1): Configuración de build actual
- [`proguard-rules.pro`](proguard-rules.pro:1): Reglas de ofuscación
- [`src/main/AndroidManifest.xml`](src/main/AndroidManifest.xml:1): Manifiesto de aplicación
- [`docs/desarrollo/4.7-etapa-7-pruebas-calidad.md`](docs/desarrollo/4.7-etapa-7-pruebas-calidad.md): Pruebas previas a despliegue
- [`docs/funcionalidades.md`](docs/funcionalidades.md): Funcionalidades desplegadas

## Resultado esperado (DoD)

- Binarios instalables y reproducibles desde CI/CD
- Firma digital válida para distribución
- Versionado consistente y traceable
- Monitoreo post-despliegue implementado
- Estrategia de rollback documentada y probada