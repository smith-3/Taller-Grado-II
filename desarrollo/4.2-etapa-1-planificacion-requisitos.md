# 4.2 Etapa 1 · Planificación y requisitos

## Objetivo

Alinear alcance del proyecto TecnoTime, levantar requisitos funcionales y no funcionales, y construir un backlog inicial con historias de usuario priorizadas. Esta etapa establece las bases sólidas para el desarrollo incremental-iterativo, asegurando que todas las funcionalidades clave estén identificadas y priorizadas antes de comenzar la implementación.

## Contexto y Alcance Inicial

TecnoTime se concibe como una aplicación móvil Android nativa para estudiantes de la Universidad Mayor de San Simón (UMSS), enfocada en la gestión inteligente de horarios académicos. El análisis inicial reveló la necesidad de automatizar procesos manuales de selección de materias y generación de horarios, aprovechando datos disponibles públicamente de la UMSS.

### Análisis del Problema
- **Situación Actual**: Estudiantes dedican horas semanales a planificar horarios manualmente, consultando PDFs estáticos y probando combinaciones.
- **Oportunidad**: La UMSS publica horarios en formato accesible vía web, permitiendo scraping automatizado.
- **Valor Propuesto**: Generación automática de horarios optimizados, reducción de tiempo de planificación del 80-90%.

## Entradas y Análisis Inicial

### 1. Contexto y Alcance (README.md)
- Definición del problema: Gestión manual ineficiente de horarios académicos.
- Solución propuesta: App móvil con scraping, generación inteligente y sincronización.
- Alcance MVP: Carreras UMSS, generación básica de horarios, exportación simple.

### 2. Funcionalidades Objetivo (docs/funcionalidades.md)
Análisis detallado de 8 categorías principales:
- Gestión de carreras y materias (scraping, selección jerárquica)
- Generación inteligente de horarios (algoritmos de optimización)
- Visualización interactiva (calendario semanal)
- Exportación múltiple (PDF, Excel, JSON)
- Sincronización (Firebase backup)
- Personalización (colores, emojis, docentes favoritos)
- Notificaciones (recordatorios automáticos)
- Sistema de notificaciones locales con WorkManager

### 3. Flujos de Usuario Existentes (docs/flujos-usuario.md)
Identificación de 4 flujos principales:
- Primer uso: Onboarding → scraping → selección → generación inicial
- Modificación: Edición manual → regeneración → aplicación
- Compartir: Exportación → importación por compañeros
- Backup: Sincronización periódica → restauración

## Actividades Detalladas

### 1. Identificación de Actores

**Actor Principal: Estudiante**
- Usuario final: Estudiantes universitarios de UMSS
- Características: Conocimiento básico de tecnología móvil, necesidad de horarios optimizados
- Interacciones: Configuración inicial, selección de materias, generación de horarios, gestión diaria

**Actores Secundarios:**
- Sistema UMSS: Fuente de datos (sitio web con horarios)
- Firebase: Servicio de backend para sincronización
- Dispositivos Android: Plataforma de ejecución

### 2. Levantamiento de Requisitos

#### Requisitos Funcionales (RF)
Basados en funcionalidades identificadas, se definieron 15 RF principales:

- **RF1**: Scraping automático de carreras, niveles, materias, grupos y horarios desde sitio UMSS
- **RF2**: Persistencia local normalizada con Room (relaciones, validaciones)
- **RF3**: Selección jerárquica usuario: Carrera → Nivel → Materia → Grupo
- **RF4**: Generación de horarios candidatos con restricciones duras/blandas
- **RF5**: Configuración de preferencias (docentes favoritos, minimizar gaps, días)
- **RF6**: Visualización semanal de horario aplicado y candidatos
- **RF7**: Exportación múltiple: PDF, Excel, imagen, JSON
- **RF8**: Importación/compartir horarios JSON
- **RF9**: Notificaciones programadas de clases
- **RF10**: Sincronización/backup de datos usuario
- **RF11**: Gestión CRUD de eventos académicos manuales
- **RF12**: Marcado docentes favoritos y consideración en generación
- **RF13**: Configuración formato hora, pesos estrategias, notificaciones por materia
- **RF14**: Vista semanal con navegación a detalle materia/evento
- **RF15**: Reintentos y feedback de red en sincronización

#### Requisitos No Funcionales (RNF)
- **RNF1**: Tiempo generación típico < 2-3s para 6×3 combinaciones
- **RNF2**: Persistencia confiable y transaccional
- **RNF3**: Operación offline para consulta horario aplicado
- **RNF4**: Accesibilidad AA (contraste, tamaños táctiles ≥48dp)
- **RNF5**: Seguridad básica datos en tránsito/reposo
- **RNF6**: Mantenibilidad (Clean Architecture, DI, separación capas)
- **RNF7**: Observabilidad mínima (logs errores scraping)
- **RNF8**: Compatibilidad Android 7.0-15
- **RNF9**: Internacionalización preparada
- **RNF10**: Rendimiento UI (recomposición controlada)
- **RNF11**: Resiliencia red (reintentos con backoff)
- **RNF12**: Consumo batería razonable
- **RNF13**: Rendimiento UI eficiente

### 3. Creación de Historias de Usuario

Se redactaron 10 historias de usuario siguiendo formato estándar:

**HU1** · Sincronizar oferta académica
- Como estudiante, quiero sincronizar carreras/niveles/materias para disponer de datos actualizados.
- Criterios: (a) ver lista carreras; (b) niveles cargan por carrera; (c) materias/grupos aparecen sin errores.

**HU2** · Seleccionar materias y grupos
- Como estudiante, quiero elegir materias y grupos de interés para componer mi horario.
- Criterios: (a) selección persistente; (b) múltiples grupos por materia; (c) validación conflictos básicos.

**HU3** · Preferencias de generación
- Como estudiante, quiero establecer prioridades (gaps, días, docentes favoritos) para orientar optimización.
- Criterios: (a) toggles/ajustes; (b) docentes marcables favoritos; (c) pesos aplicados al score.

**HU4** · Generar horarios candidatos
- Como estudiante, quiero generar varias opciones de horario sin solapamientos para elegir mejor.
- Criterios: (a) al menos N candidatos ordenados; (b) sin conflictos duros; (c) métricas visibles.

**HU5** · Aplicar horario
- Como estudiante, quiero aplicar horario candidato como oficial semanal.
- Criterios: (a) vista semanal poblada; (b) persistencia; (c) navegación detalle.

**HU6** · Exportar horario
- Como estudiante, quiero exportar horario a PDF/Excel/imagen/JSON para compartir/imprimir.
- Criterios: (a) archivos generados sin errores; (b) formato legible; (c) nombre consistente.

**HU7** · Importar horario compartido
- Como estudiante, quiero importar horario JSON compartido por compañero.
- Criterios: (a) validación esquema; (b) vista previa; (c) fusión o reemplazo.

**HU8** · Notificaciones de clases
- Como estudiante, quiero recibir recordatorios antes de cada clase.
- Criterios: (a) permiso gestionado; (b) programación por día/hora; (c) acciones posponer/descartar.

**HU9** · Eventos académicos manuales
- Como estudiante, quiero agregar eventos puntuales (exámenes, reuniones) al calendario.
- Criterios: (a) CRUD básico; (b) colisión detectada; (c) visibilidad semanal.

**HU10** · Copia de seguridad
- Como estudiante, quiero respaldar y restaurar datos en nube.
- Criterios: (a) backup disparable; (b) restore con confirmación; (c) integridad post-restore.

### 4. Priorización y Construcción del Backlog

#### Método MoSCoW
- **Must Have**: HU1, HU2, HU4, HU5, HU6 (funcionalidad core)
- **Should Have**: HU3, HU7, HU8 (mejoras UX)
- **Could Have**: HU9, HU10 (funcionalidades avanzadas)
- **Won't Have**: Características fuera de alcance MVP

#### Épicas Definidas
- **E1**: Sincronización oferta académica (HU1)
- **E2**: Selección y preferencias (HU2, HU3)
- **E3**: Generación y aplicación horarios (HU4, HU5)
- **E4**: Exportación/Importación (HU6, HU7)
- **E5**: Notificaciones y eventos (HU8, HU9)
- **E6**: Backup/Restore (HU10)
- **E7**: Calidad y despliegue

#### Tareas Técnicas Identificadas
- Descubrir endpoints UMSS scrapeables
- Implementar parsing PDF horarios
- DAOs e inserciones transaccionales
- UI selección jerárquica
- Backtracking + heurísticas
- Exportar formatos múltiples
- WorkManager para notificaciones

### 5. Identificación de Riesgos

#### Riesgos Técnicos
- **Cambio estructura HTML/PDF UMSS**: Mitigación con feature flags y pruebas integración
- **Inestabilidad red**: Reintentos con backoff, caché local
- **Complejidad combinatoria**: Poda temprana, límites tiempo

#### Riesgos de Proyecto
- **Alcance creep**: Definición clara MVP, aprobación cambios
- **Dependencia datos UMSS**: Múltiples fuentes backup, comunicación universidad

## Decisiones Tomadas Basadas en Análisis del Código Fuente

### Arquitectura: Clean Architecture
**Decisión**: Implementar Clean Architecture con capas Presentación/Dominio/Datos
**Justificación**: Análisis código mostró necesidad separación responsabilidades, testabilidad, evolución tecnológica
**Evidencia**: Capas domain/usecase, data/repository, presentation/viewmodel en estructura actual

### Persistencia: Room con Relaciones
**Decisión**: Usar Room para BD local con junction tables
**Justificación**: Modelo ER complejo (carreras→grupos→materias), necesidad integridad referencial
**Evidencia**: Entities con @Relation, DAOs con transacciones

### Algoritmo Generación: Backtracking + Estrategias
**Decisión**: Backtracking con patrón Strategy para evaluación
**Justificación**: Combinatoria alta requiere optimización, criterios múltiples configurables
**Evidencia**: domain/service/*Strategy.kt, ScheduleGeneratorUseCase

### Inyección Dependencias: Hilt
**Decisión**: Hilt para DI automática
**Justificación**: Complejidad dependencias entre capas, mantenibilidad
**Evidencia**: @HiltViewModel, @Inject en constructores

### UI: Jetpack Compose
**Decisión**: Compose para UI declarativa
**Justificación**: Modernidad, rendimiento, consistencia Material Design 3
**Evidencia**: presentation/*/Screen.kt con @Composable

## Herramientas Utilizadas

### Análisis y Diseño
- **Markdown**: Documentación estructurada
- **Mermaid**: Diagramas flujos y arquitectura
- **Draw.io/PlantUML**: Diagramas técnicos

### Gestión de Requisitos
- **Tablero Kanban**: Seguimiento progreso (backlog-tareas.md)
- **Formatos HU estándar**: Plantilla consistente
- **Matriz trazabilidad**: HU → RF → módulos

### Validación
- **Prototipos papel/digital**: Validación flujos usuario
- **Análisis código existente**: Decisiones basadas en implementación actual

## Desafíos Enfrentados

### 1. Complejidad del Dominio Académico
**Desafío**: Modelar jerarquía carrera→nivel→materia→grupo con prerrequisitos
**Solución**: Análisis detallado flujos-usuario.md, definición RF3 clara
**Resultado**: Modelo de datos robusto con validaciones

### 2. Balance Funcionalidades vs. Alcance MVP
**Desafío**: 8 categorías funcionalidades identificadas, riesgo sobrecarga
**Solución**: Priorización MoSCoW estricta, foco core funcional
**Resultado**: MVP definido con 10 HU prioritarias

### 3. Integración con Datos Externos
**Desafío**: Dependencia scraping UMSS, cambios potenciales estructura
**Solución**: Diseño resiliente con validadores, feature flags
**Resultado**: Arquitectura preparada para evolución datos fuente

### 4. Definición Criterios de Aceptación
**Desafío**: Criterios demasiado vagos o demasiado específicos
**Solución**: Patrón INVEST para HU, criterios SMART
**Resultado**: Criterios medibles y verificables

## Resultados Obtenidos

### Artefactos Completados
- **requisitos.md**: 15 RF + 13 RNF consolidados
- **historias-de-usuario.md**: 10 HU con criterios aceptación
- **backlog-tareas.md**: 7 épicas, 15+ tareas priorizadas
- **trazabilidad.md**: Mapeo HU → módulos/archivos
- **criterios-aceptacion-definicion-de-terminado.md**: DoD por HU

### Métricas de Calidad
- **Cobertura funcional**: 100% funcionalidades docs/funcionalidades.md mapeadas
- **Trazabilidad**: 100% HU con criterios aceptación definidos
- **Priorización**: 70% Must Have, 20% Should Have, 10% Could Have

### Preparación para Desarrollo
- **Base sólida**: Requisitos claros, backlog priorizado
- **Arquitectura definida**: Decisiones ADR tomadas
- **Riesgos mitigados**: Planes contingencia identificados

## Ejemplos Concretos

### Historia de Usuario Completa
**HU4 · Generar horarios candidatos**
- **Como** estudiante de Ingeniería Informática
- **Quiero** generar 5 opciones de horario para 6 materias
- **Para** elegir el que mejor se adapte a mis preferencias
- **Criterios de Aceptación**:
  - Dado que seleccioné 6 materias con múltiples grupos
  - Cuando ejecuto generación con "minimizar gaps" activado
  - Entonces veo 5 horarios ordenados por score
  - Y ningún horario tiene conflictos de horario
  - Y el score refleja reducción de gaps entre clases

### Item de Backlog
```
[ ] Implementar backtracking + heurísticas MRV/LCV/poda (E3)
  - Estimación: 3-4 días
  - Dependencias: Modelo datos completo
  - Criterios: Genera combinaciones válidas sin conflictos
  - Riesgos: Complejidad computacional
```

### Trazabilidad HU → Módulos
**HU4 → Generar horarios candidatos**
- Use cases: `domain/usecase/ScheduleGeneratorUseCaseImpl.kt`
- Estrategias: `domain/service/*Strategy*.kt`
- UI: `presentation/generateSchedule/*`
- Tests: `test/domain/service/*Test.kt`

### Definición de Terminado (DoD)
**HU4 Completada cuando:**
- Compila en variante release sin errores
- Genera al menos 3 candidatos sin conflictos duros
- Score calculado correctamente con métricas visibles
- UI muestra progreso y resultados ordenados
- Documentación actualizada con ejemplos

## Referencias Cruzadas

- [docs/funcionalidades.md](docs/funcionalidades.md): Funcionalidades detalladas implementadas
- [docs/flujos-usuario.md](docs/flujos-usuario.md): Flujos validación HU
- [docs/decisiones-diseno-adr.md](docs/decisiones-diseno-adr.md): Decisiones arquitectura tomadas
- [docs/arquitectura.md](docs/arquitectura.md): Implementación arquitectura elegida
- [docs/modelo-datos-er.md](docs/modelo-datos-er.md): Modelo datos resultante
- [docs/algoritmos-generacion-horarios.md](docs/algoritmos-generacion-horarios.md): Algoritmos implementados

## Entregables

- requisitos.md consolidado con 15 RF + 13 RNF
- historias-de-usuario.md con 10 HU priorizadas y criterios aceptación
- backlog-tareas.md con 7 épicas y 15+ tareas secuenciadas
- Trazabilidad inicial HU → módulos en trazabilidad.md
- criterios-aceptacion-definicion-de-terminado.md con DoD por HU

## Resultado Esperado (DoD)

- Backlog completo y priorizado listo para iniciar Etapa 2
- Criterios de aceptación definidos y verificables para HU prioritarias
- Arquitectura y tecnologías decididas basadas en análisis código
- Riesgos identificados con planes mitigación
- Documentación completa y actualizada
